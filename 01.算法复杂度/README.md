# 复杂度分析

## 为什么需要分析复杂度

- 测试结果会依赖测试环境
- 测试结果受数据规模的影响很大

## 时间复杂度分析

三种方法分析

### 1. 只关注循环执行次数最多的一段代码

```go
func cal(n int) {
  sum := 0
  i := 1
  for ; i <= n; i++ {
    sum += i
  }
  return sum
}
```

在上面的代码中，`sum := 0`,`i := 1`，都是常量级，与`n`的大小无关，而循环的代码被执行了`n`次，所有时间复杂度就是`O(n)`

### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

```go
func cal2(n int) {
	//第一段代码
	for i := 1; i <= 100; i++ {
		print(i)
	}

	// 第二段代码
	for i := 0; i < n; i++ {
		print(i)
	}

	// 第三段代码
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			print(i * i)
		}
	}
}
```

上面有三段代码，一段段分析:
- 第一段执行了100次，这是个确定的次数，也就是哪怕执行100000，也跟n无关，不影响复杂度
- 第二段执行了n次
- 第三段执行了n*n次

根据总的时间复杂度等于量级最大的代码的时间复杂度，这段的时间复杂度就是O(n²)

### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

> 就是上面第三段代码的情况


## 常见时间复杂度实例分析

### O(1)

```go
func main() {
  a := 1
  b := 2
  c := 3
}
```

不管有多少行要执行的代码，只要代码的执行时间不随`n`的增大而增大，那时间复杂度就是`O(1)`

