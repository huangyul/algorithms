# 复杂度分析

## 为什么需要分析复杂度

- 测试结果会依赖测试环境
- 测试结果受数据规模的影响很大

## 时间复杂度分析

三种方法分析

### 1. 只关注循环执行次数最多的一段代码

```go
func cal(n int) {
  sum := 0
  i := 1
  for ; i <= n; i++ {
    sum += i
  }
  return sum
}
```

在上面的代码中，`sum := 0`,`i := 1`，都是常量级，与`n`的大小无关，而循环的代码被执行了`n`次，所有时间复杂度就是`O(n)`

### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

```go
func cal2(n int) {
	//第一段代码
	for i := 1; i <= 100; i++ {
		print(i)
	}

	// 第二段代码
	for i := 0; i < n; i++ {
		print(i)
	}

	// 第三段代码
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			print(i * i)
		}
	}
}
```

上面有三段代码，一段段分析:
- 第一段执行了100次，这是个确定的次数，也就是哪怕执行100000，也跟n无关，不影响复杂度
- 第二段执行了n次
- 第三段执行了n*n次

根据总的时间复杂度等于量级最大的代码的时间复杂度，这段的时间复杂度就是O(n²)

### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

> 就是上面第三段代码的情况


## 常见时间复杂度实例分析

### O(1)

```go
func main() {
  a := 1
  b := 2
  c := 3
}
```

不管有多少行要执行的代码，只要代码的执行时间不随`n`的增大而增大，那时间复杂度就是`O(1)`

### 2. O(logn), O(nlogn)

对数时间的复杂度

```go
i := 1
for i <= n {
  i = i * 2
}
```

上面的代码可以理解成等比数列，所有复杂度就为对数   
无论是以几为底的对数，时间复杂度一律是`O(logn)`


`O(nlogn)`就是乘积法则

### 3. O(m + n)

时间复杂度由两种数据的规模决定，例如

```go
func cal(n int, m int) {
  for i := 0; i < n; i++ {
    // ...
  }
  for i := 0; i < m; i++ {
    // ...
  }
}
```

这样由两种不同数据模型决定的，无法使用最大量级原则，所以复杂度是`O(n+m)`，同理如果是嵌套就是`O(n*m)`

## 空间复杂度

表示算法的存储空间与数据模型之间的关系

```go
func main() {
  i := 1
  arr := [4]{1,2,3,4}
}
```

上面我们申请了4个空间的数组，但是还是与`n`无关，所以空间复杂度还是`O(1)`，如果改为`n`由传参决定，来初始化切片的大小，那空间复杂度就是`O(n)`

## 深入分析复杂度

- 最好情况时间复杂度
- 最坏情况时间复杂度
- 平均情况时间复杂度
- 均摊时间复杂度

### 最好、最坏情况时间复杂度

```go
// 最好、最坏时间复杂度
// n表示arr的长度
func f1(arr []int, n int, x int) int {
	i := 0
	pos := -1
	for ; i < n; i++ {
		if arr[i] == x {
			pos = i
		}
	}
	return pos
}
```

在上面的代码中，时间复杂度可以看出是`O(n)`，但是正常写代码时我们可以在找到后使用`break`跳出循环，如下面代码

```go
func f1(arr []int, n int, x int) int {
	i := 0
	pos := -1
	for ; i < n; i++ {
		if arr[i] == x {
			pos = i
      break
		}
	}
	return pos
}
```

这个时候，代码在不同情况会有不同的时间复杂度

- 最好的情况，第一个就找到了
- 最坏的情况，最有后一个才找到

### 平均时间复杂度

上面最好情况时间复杂度和最坏情况时间复杂度都是极端情况下的，发生的概率很小，这时候为了更好的表示，要使用**平均情况时间复杂度**

如何计算上面的平均情况时间复杂度?   
1. 在数组中和不在数组中的概率都是`二分之一`
2. 在`0~n-1`这`n`个位置中的概率也是一样的，是`n分之1`
（后面的有点难，先不理解）

> 还有均摊时间复杂度？？
